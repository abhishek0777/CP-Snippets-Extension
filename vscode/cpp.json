{
	"CP template": {
		"prefix": "cptemplate",
		"body": [
		  "#include <bits/stdc++.h>",
		  "#define ll long long int",
		  "#define FAST ios_base::sync_with_stdio(false); cin.tie(NULL);",
		  "using namespace std;",
		  "",
		  "#define MOD 1000000007",
		  "/*",
		  "   notes",
		  "",
		  "*/",
		  "",
		  "",
		  "void solve()",
		  "{",
		  "  ",
		  "}",
		  "",
		  "",
		  "int main() {",
		  "  FAST",
		  "  ll t = 1;",
		  "  cin >> t;",
		  "  while (t--)solve();",
		  "  return 0;",
		  "}"
		],
		"description": "CP template"
	},
	"Check number is power of two": {
		"prefix": "isPowerOfTwo",
		"body": [
		  "bool isPowerOfTwo(int n) {",
		  "  return n && (!(n & (n - 1)));",
		  "}"
		],
		"description": "Check number is power of two"
	},
	"Check number is prime": {
		"prefix": "isPrime",
		"body": [
		  "bool isPrime(int n)",
		  "{",
		  "  for (int i = 2; i * i <= n; i++) {",
		  "    if (n % i == 0)return false;",
		  "  }",
		  "  return true;",
		  "}"
		],
		"description": "Check number is prime"
	},
	"return all prime factors": {
		"prefix": "primeFactors",
		"body": [
		  "vector<int> primeFactors(int n)",
		  "{",
		  "  vector<int> v;",
		  "  if (n % 2 == 0) {",
		  "    v.push_back(2);",
		  "    while (n % 2 == 0)n /= 2;",
		  "  }",
		  "  for (int i = 3; i * i <= n; i += 2) {",
		  "    if (n % i == 0) {",
		  "      v.push_back(i);",
		  "      while (n % i == 0)n /= i;",
		  "    }",
		  "  }",
		  "  if (n > 2)v.push_back(n);",
		  "  return v;",
		  "}"
		],
		"description": "return all prime factors"
	},
	"count of all divisors": {
		"prefix": "countDivisors",
		"body": [
		  "//counts the number of divisors",
		  "int countDivisors(int n)",
		  "{",
		  "  int ans = 1;",
		  "  int curr = 0;",
		  "  while (n % 2 == 0)curr++, n /= 2;",
		  "  ans *= (curr + 1);",
		  "  curr = 0;",
		  "  for (int i = 3; i * i <= n; i += 2) {",
		  "    curr = 0;",
		  "    while (n % i == 0) {",
		  "      curr++;",
		  "      n /= i;",
		  "    }",
		  "    ans *= (curr + 1);",
		  "  }",
		  "  if (n > 2)ans *= 2;",
		  "  return ans;",
		  "}"
		],
		"description": "count of all divisors"
	},
	"sum of all divisors": {
		"prefix": "divisorFunction",
		"body": [
		  "//return sum all divisors",
		  "int divisorFunction(int n)",
		  "{",
		  "  int ans = 1;",
		  "  int power = 0;",
		  "  while (n % 2 == 0)power++, n /= 2;",
		  "  //sum of GP",
		  "  ans *= (pow(2, power + 1) - 1);",
		  "  for (int i = 3; i * i <= n; i += 2) {",
		  "    power = 0;",
		  "    while (n % i == 0) {",
		  "      power++;",
		  "      n /= i;",
		  "    }",
		  "    ans *= (pow(i, power + 1) - 1) / (i - 1);",
		  "  }",
		  "  return ans;",
		  "}"
		],
		"description": "sum of all divisors"
	},
	"return n!": {
		"prefix": "nFactorial",
		"body": [
		  "//when n! <1e18 and you need raw",
		  "long long int nFactorial(int n)",
		  "{",
		  "  long long int ans = 1;",
		  "  for (int i = 2; i <= n; i++)ans *= i;",
		  "  return ans;",
		  "}"
		],
		"description": "return n!"
	},
	"return n!%mod": {
		"prefix": "nFactorialMOD",
		"body": [
		  "// n!%mod  ,for ex mod=1e9+7",
		  "int nFactorialMOD(int n, int mod)",
		  "{",
		  "  int ans = 1;",
		  "  for (int i = 2; i <= n; i++)(ans *= i) %= mod;",
		  "  return ans;",
		  "}"
		],
		"description": "return n!%mod"
	},
	"next power of two": {
		"prefix": "nextPowerOfTwo",
		"body": [
		  "int nextPowerOfTwo(int n)",
		  "{",
		  "  //if n is power of two",
		  "  if (n && (!n & (n - 1)))return n;",
		  "  return 1 << ((int)ceil(log2(n)));",
		  "}"
		],
		"description": "next power of two"
	},
	"prev power of two": {
		"prefix": "prevPowerOfTwo",
		"body": [
		  "int prevPowerOfTwo(int n)",
		  "{",
		  "  //if n is power of two",
		  "  if (n && (!n & (n - 1)))return n;",
		  "  return 1 << ((int)ceil(log2(n) - 1));",
		  "}"
		],
		"description": "prev power of two"
	},
	"x^y": {
		"prefix": "xpowery",
		"body": [
		  "long long int xpowery(long long int x,long long int y) {",
		  "  long long int res = 1;",
		  "  /*",
		  "  it depends sometimes on questions too,",
		  "  whether pow(0,0) is 1 or 0",
		  "  So change accordingly",
		  "  */",
		  "  if (x == 0)return 0LL;",
		  "  while (y)",
		  "  {",
		  "    if (y & 1)res *= x;",
		  "    y >>= 1;",
		  "    x *= x;",
		  "  }",
		  "  return res;",
		  "}"
		],
		"description": "x^y"
	},
	"(x^y)%mod": {
		"prefix": "xpoweryMOD",
		"body": [
		  "long long int xpoweryMOD(long long int x,long long int y, int mod)",
		  "{",
		  "  long long int res = 1;",
		  "  /*",
		  "  it depends sometimes on questions too,",
		  "  whether pow(0,0) is 1 or 0",
		  "  So change accordingly",
		  "  */",
		  "  if (x == 0)return 0;",
		  "  while (y)",
		  "  {",
		  "    if (y & 1)(res *= x) %= mod;",
		  "    y >>= 1;",
		  "    (x *= x) %= mod;",
		  "  }",
		  "  return res;",
		  "}"
		],
		"description": "(x^y)%mod"
	},
	"sieve of eratosthenes": {
		"prefix": "sieve",
		"body": [
		  "//return all primes b/w 1 to n",
		  "vector<int> sieve(int n)",
		  "{",
		  "   vector<bool> is(n + 1, true);",
		  "   vector<int> primes;",
		  "   for (int i = 2; i * i <= n; i++) {",
		  "      if (is[i]) {",
		  "         for (int p = i * i; p <= n; p += i)is[p] = false;",
		  "      }",
		  "   }",
		  "   for (int i = 2; i <= n; i++)",
		  "      if (is[i])primes.push_back(i);",
		  "   return primes;",
		  "}"
		],
		"description": "sieve of eratosthenes"
	},
	"Combinatorics": {
		"prefix": "combinatorics",
		"body": [
		  "int SIZE = 2000005;",
		  "vector<int> fact(SIZE, 1);",
		  "vector<int> inv(SIZE, 1);",
		  "int inverse(int x, int y)",
		  "{",
		  "   int res = 1;",
		  "   while (y) {",
		  "      if (y & 1)res = (1LL * res * x) % MOD;",
		  "      y >>= 1;",
		  "      x = (1LL * x * x) % MOD;",
		  "   }",
		  "   return res;",
		  "}",
		  "void initCombinatorics()",
		  "{",
		  "   for (int i = 2; i < SIZE; i++) {",
		  "      fact[i] = (1LL * fact[i - 1] * i) % MOD;",
		  "      inv[i] = inverse(fact[i], MOD - 2);",
		  "   }",
		  "}",
		  "int nCr(int n, int r)",
		  "{",
		  "   int res = 1;",
		  "   if (r > n)return 0;",
		  "   res = (1LL * fact[n] * inv[r]) % MOD;",
		  "   res = (1LL * res * inv[n - r]) % MOD;",
		  "   return res;",
		  "}"
		],
		"description": "Combinatorics"
	},
	"topological sort": {
		"prefix": "topologicalSort",
		"body": [
		  "vector<int> topologicalSort(vector<int> adj[], int N) {",
		  "   vector<int> in(N, 0), tsort;",
		  "   for (int u = 0; u < N; u++) {",
		  "      for (int v : adj[u])in[v]++;",
		  "   }",
		  "   queue<int> q;",
		  "   for (int i = 0; i < N; i++) {",
		  "      if (in[i] == 0)q.push(i);",
		  "   }",
		  "   while (!q.empty()) {",
		  "      int u = q.front();",
		  "      q.pop();",
		  "      tsort.push_back(u);",
		  "      for (int v : adj[u]) {",
		  "         in[v]--;",
		  "         if (in[v] == 0)q.push(v);",
		  "      }",
		  "   }",
		  "   return tsort;",
		  "}"
		],
		"description": "topological sort"
	},
	"Check cycle in undirected Graph": {
		"prefix": "cycleInUnDirectedGraph",
		"body": [
		  "//call cycleInUndirectedGraph function to check cycle",
		  "bool dfs(int s, int p, vector<int> adj[], vector<bool> &vis) {",
		  "   vis[s] = true;",
		  "   for (int v : adj[s]) {",
		  "      if (!vis[v]){",
		  "         if(dfs(v, s, adj, vis))return true;",
		  "      }",
		  "      else if (v != p)return true;",
		  "   }",
		  "   return false;",
		  "}",
		  "",
		  "bool cycleInUndirectedGraph(vector<int> adj[], int n)",
		  "{",
		  "   vector<bool> vis(n, false);",
		  "   for (int u = 0; u < n; u++) {",
		  "      if (!vis[u]) {",
		  "         if (dfs(u, -1, adj, vis))return true;",
		  "      }",
		  "   }",
		  "   return false;",
		  "}"
		],
		"description": "Check cycle in undirected Graph"
	},
	"Check cycle in directed Graph": {
		"prefix": "cycleInDirectedGraph",
		"body": [
		  "//call cycleInDirectedGraph to check cycle",
		  "bool dfs(int s, vector<bool> &vis, vector<bool> &recSt, vector<int> adj[])",
		  "{",
		  "   recSt[s] = vis[s] = true;",
		  "   for (int v : adj[s]) {",
		  "      if (!vis[v]) {",
		  "         if (dfs(v, vis, recSt, adj))return true;",
		  "      }",
		  "      else if (recSt[v])return true;",
		  "   }",
		  "   recSt[s] = false;",
		  "   return false;",
		  "}",
		  "",
		  "bool cycleInDirectedGraph(vector<int> adj[], int n)",
		  "{",
		  "   vector<bool> vis(n, false), recSt(n, false);",
		  "   for (int u = 0; u < n; u++) {",
		  "      if (!vis[u]) {",
		  "         if (dfs(u, vis, recSt, adj))return true;",
		  "      }",
		  "   }",
		  "   return false;",
		  "}"
		],
		"description": "Check cycle in directed Graph"
	},
	"Dijkstra shortest path algorithm": {
		"prefix": "dijkstra",
		"body": [
		  "vector<int> dijkstra(vector<pair<int, int>> adj[], int s, int n)",
		  "{",
		  "   priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;",
		  "   vector<int> dist(n, INT_MAX);",
		  "   dist[s] = 0;",
		  "   pq.push({dist[s], s});",
		  "   while (!pq.empty()) {",
		  "      int u = pq.top().second;",
		  "      int d_u = pq.top().first;",
		  "      pq.pop();",
		  "      if (d_u != dist[u])continue;",
		  "      for (pair<int, int> edge : adj[u]) {",
		  "         int wt = edge.second;",
		  "         int v = edge.first;",
		  "         if (dist[u] != INT_MAX && dist[v] > dist[u] + wt) {",
		  "            dist[v] = dist[u] + wt;",
		  "            pq.push({dist[v], v});",
		  "         }",
		  "      }",
		  "   }",
		  "   return dist;",
		  "}"
		],
		"description": "Dijkstra shortest path algorithm"
	},
	"Bellman Ford shortest path algorithm": {
		"prefix": "bellmanFord",
		"body": [
		  "vector<int> bellmanFord(vector<pair<int, int>> adj[], int s, int n)",
		  "{",
		  "   int INF = INT_MAX;",
		  "   vector<int> dist(n, INF);",
		  "   dist[s] = 0;",
		  "   for (int cnt = 0; cnt < n - 1; cnt++) {",
		  "      for (int i = 0; i < n; i++) {",
		  "         for (pair<int, int> edge : adj[i]) {",
		  "            int wt = edge.second;",
		  "            int v = edge.first;",
		  "            if (dist[i] != INF && dist[v] > dist[i] + wt) {",
		  "               dist[v] = dist[i] + wt;",
		  "            }",
		  "         }",
		  "      }",
		  "   }",
		  "   return dist;",
		  "}"
		],
		"description": "Bellman Ford shortest path algorithm"
	},
	"Detect negative cycle": {
		"prefix": "detectNegativeCycle",
		"body": [
		  "bool detectNegativeCycle(vector<pair<int, int>> adj[], int s, int n)",
		  "{",
		  "   int INF = INT_MAX;",
		  "   vector<int> dist(n, INF);",
		  "   dist[s] = 0;",
		  "   for (int cnt = 0; cnt < n - 1; cnt++) {",
		  "      for (int i = 0; i < n; i++) {",
		  "         for (pair<int, int> edge : adj[i]) {",
		  "            int wt = edge.second;",
		  "            int v = edge.first;",
		  "            if (dist[i] != INF && dist[v] > dist[i] + wt) {",
		  "               dist[v] = dist[i] + wt;",
		  "            }",
		  "         }",
		  "      }",
		  "   }",
		  "   for (int i = 0; i < n; i++) {",
		  "      for (pair<int, int> edge : adj[i]) {",
		  "         int wt = edge.second;",
		  "         int v = edge.first;",
		  "         if (dist[i] != INF && dist[v] > dist[i] + wt) {",
		  "            return true;",
		  "         }",
		  "      }",
		  "   }",
		  "   return false;",
		  "}"
		],
		"description": "Detect negative cycle"
	},
	"Disjoint union data structures": {
		"prefix": "DSU",
		"body": [
		  "vector<int> parent;",
		  "void initDSU(int N) {",
		  "   parent.assign(N + 1, 0);",
		  "   iota(parent.begin(), parent.end(), 0);",
		  "}",
		  "int findDSU(int x) {",
		  "   if (x == parent[x])return x;",
		  "   return parent[x] = findDSU(parent[x]);",
		  "}",
		  "void unionDSU(int x, int y) {",
		  "   int px = findDSU(x);",
		  "   int py = findDSU(y);",
		  "   if (px != py) {",
		  "      parent[py] = px;",
		  "   }",
		  "}"
		],
		"description": "Disjoint union data structures"
	}
	
	
}