{
    "CP template": {
        "prefix": "cptemplate",
        "body": [
            "#include <bits/stdc++.h>",
            "#define ll long long int",
            "#define FAST ios_base::sync_with_stdio(false); cin.tie(NULL);",
            "using namespace std;",
            "",
            "#define MOD 1000000007",
            "/*",
            "   notes",
            "",
            "*/",
            "",
            "",
            "void solve()",
            "{",
            "  ",
            "}",
            "",
            "",
            "int main() {",
            "  FAST",
            "  ll t = 1;",
            "  cin >> t;",
            "  while (t--)solve();",
            "  return 0;",
            "}"
        ],
        "description": "CP template"
    },
    "Check number is power of two": {
        "prefix": "isPowerOfTwo",
        "body": [
            "bool isPowerOfTwo(int n) {",
            "  return n && (!(n & (n - 1)));",
            "}"
        ],
        "description": "Check number is power of two"
    },
    "Check number is prime": {
        "prefix": "isPrime",
        "body": [
            "bool isPrime(int n)",
            "{",
            "  for (int i = 2; i * i <= n; i++) {",
            "    if (n % i == 0)return false;",
            "  }",
            "  return true;",
            "}"
        ],
        "description": "Check number is prime"
    },
    "return all prime factors": {
        "prefix": "primeFactors",
        "body": [
            "vector<int> primeFactors(int n)",
            "{",
            "  vector<int> v;",
            "  if (n % 2 == 0) {",
            "    v.push_back(2);",
            "    while (n % 2 == 0)n /= 2;",
            "  }",
            "  for (int i = 3; i * i <= n; i += 2) {",
            "    if (n % i == 0) {",
            "      v.push_back(i);",
            "      while (n % i == 0)n /= i;",
            "    }",
            "  }",
            "  if (n > 2)v.push_back(n);",
            "  return v;",
            "}"
        ],
        "description": "return all prime factors"
    },
    "count of all divisors": {
        "prefix": "countDivisors",
        "body": [
            "//counts the number of divisors",
            "int countDivisors(int n)",
            "{",
            "  int ans = 1;",
            "  int curr = 0;",
            "  while (n % 2 == 0)curr++, n /= 2;",
            "  ans *= (curr + 1);",
            "  curr = 0;",
            "  for (int i = 3; i * i <= n; i += 2) {",
            "    curr = 0;",
            "    while (n % i == 0) {",
            "      curr++;",
            "      n /= i;",
            "    }",
            "    ans *= (curr + 1);",
            "  }",
            "  if (n > 2)ans *= 2;",
            "  return ans;",
            "}"
        ],
        "description": "count of all divisors"
    },
    "sum of all divisors": {
        "prefix": "divisorFunction",
        "body": [
            "//return sum all divisors",
            "int divisorFunction(int n)",
            "{",
            "  int ans = 1;",
            "  int power = 0;",
            "  while (n % 2 == 0)power++, n /= 2;",
            "  //sum of GP",
            "  ans *= (pow(2, power + 1) - 1);",
            "  for (int i = 3; i * i <= n; i += 2) {",
            "    power = 0;",
            "    while (n % i == 0) {",
            "      power++;",
            "      n /= i;",
            "    }",
            "    ans *= (pow(i, power + 1) - 1) / (i - 1);",
            "  }",
            "  return ans;",
            "}"
        ],
        "description": "sum of all divisors"
    },
    "return n!": {
        "prefix": "nFactorial",
        "body": [
            "//when n! <1e18 and you need raw",
            "long long int nFactorial(int n)",
            "{",
            "  long long int ans = 1;",
            "  for (int i = 2; i <= n; i++)ans *= i;",
            "  return ans;",
            "}"
        ],
        "description": "return n!"
    },
    "return n!%mod": {
        "prefix": "nFactorialMOD",
        "body": [
            "// n!%mod  ,for ex mod=1e9+7",
            "int nFactorialMOD(int n, int mod)",
            "{",
            "  int ans = 1;",
            "  for (int i = 2; i <= n; i++)(ans *= i) %= mod;",
            "  return ans;",
            "}"
        ],
        "description": "return n!%mod"
    },
    "next power of two": {
        "prefix": "nextPowerOfTwo",
        "body": [
            "int nextPowerOfTwo(int n)",
            "{",
            "  //if n is power of two",
            "  if (n && (!n & (n - 1)))return n;",
            "  return 1 << ((int)ceil(log2(n)));",
            "}"
        ],
        "description": "next power of two"
    },
    "prev power of two": {
        "prefix": "prevPowerOfTwo",
        "body": [
            "int prevPowerOfTwo(int n)",
            "{",
            "  //if n is power of two",
            "  if (n && (!n & (n - 1)))return n;",
            "  return 1 << ((int)ceil(log2(n) - 1));",
            "}"
        ],
        "description": "prev power of two"
    },
    "x^y": {
        "prefix": "xpowery",
        "body": [
            "long long int xpowery(long long int x,long long int y) {",
            "  long long int res = 1;",
            "  /*",
            "  it depends sometimes on questions too,",
            "  whether pow(0,0) is 1 or 0",
            "  So change accordingly",
            "  */",
            "  if (x == 0)return 0LL;",
            "  while (y)",
            "  {",
            "    if (y & 1)res *= x;",
            "    y >>= 1;",
            "    x *= x;",
            "  }",
            "  return res;",
            "}"
        ],
        "description": "x^y"
    },
    "(x^y)%mod": {
        "prefix": "xpoweryMOD",
        "body": [
            "long long int xpoweryMOD(long long int x,long long int y, int mod)",
            "{",
            "  long long int res = 1;",
            "  /*",
            "  it depends sometimes on questions too,",
            "  whether pow(0,0) is 1 or 0",
            "  So change accordingly",
            "  */",
            "  if (x == 0)return 0;",
            "  while (y)",
            "  {",
            "    if (y & 1)(res *= x) %= mod;",
            "    y >>= 1;",
            "    (x *= x) %= mod;",
            "  }",
            "  return res;",
            "}"
        ],
        "description": "(x^y)%mod"
    },
    "sieve of eratosthenes": {
        "prefix": "sieve",
        "body": [
            "//return all primes b/w 1 to n",
            "vector<int> sieve(int n)",
            "{",
            "   vector<bool> is(n + 1, true);",
            "   vector<int> primes;",
            "   for (int i = 2; i * i <= n; i++) {",
            "      if (is[i]) {",
            "         for (int p = i * i; p <= n; p += i)is[p] = false;",
            "      }",
            "   }",
            "   for (int i = 2; i <= n; i++)",
            "      if (is[i])primes.push_back(i);",
            "   return primes;",
            "}"
        ],
        "description": "sieve of eratosthenes"
    },
    "Combinatorics": {
        "prefix": "combinatorics",
        "body": [
            "int SIZE = 2000005;",
            "vector<int> fact(SIZE, 1);",
            "vector<int> inv(SIZE, 1);",
            "int inverse(int x, int y)",
            "{",
            "   int res = 1;",
            "   while (y) {",
            "      if (y & 1)res = (1LL * res * x) % MOD;",
            "      y >>= 1;",
            "      x = (1LL * x * x) % MOD;",
            "   }",
            "   return res;",
            "}",
            "void initCombinatorics()",
            "{",
            "   for (int i = 2; i < SIZE; i++) {",
            "      fact[i] = (1LL * fact[i - 1] * i) % MOD;",
            "      inv[i] = inverse(fact[i], MOD - 2);",
            "   }",
            "}",
            "int nCr(int n, int r)",
            "{",
            "   int res = 1;",
            "   if (r > n)return 0;",
            "   res = (1LL * fact[n] * inv[r]) % MOD;",
            "   res = (1LL * res * inv[n - r]) % MOD;",
            "   return res;",
            "}"
        ],
        "description": "Combinatorics"
    },
    "topological sort": {
        "prefix": "topologicalSort",
        "body": [
            "vector<int> topologicalSort(vector<int> adj[], int N) {",
            "   vector<int> in(N, 0), tsort;",
            "   for (int u = 0; u < N; u++) {",
            "      for (int v : adj[u])in[v]++;",
            "   }",
            "   queue<int> q;",
            "   for (int i = 0; i < N; i++) {",
            "      if (in[i] == 0)q.push(i);",
            "   }",
            "   while (!q.empty()) {",
            "      int u = q.front();",
            "      q.pop();",
            "      tsort.push_back(u);",
            "      for (int v : adj[u]) {",
            "         in[v]--;",
            "         if (in[v] == 0)q.push(v);",
            "      }",
            "   }",
            "   return tsort;",
            "}"
        ],
        "description": "topological sort"
    },
    "Check cycle in undirected Graph": {
        "prefix": "cycleInUnDirectedGraph",
        "body": [
            "//call cycleInUndirectedGraph function to check cycle",
            "bool dfs(int s, int p, vector<int> adj[], vector<bool> &vis) {",
            "   vis[s] = true;",
            "   for (int v : adj[s]) {",
            "      if (!vis[v]){",
            "         if(dfs(v, s, adj, vis))return true;",
            "      }",
            "      else if (v != p)return true;",
            "   }",
            "   return false;",
            "}",
            "",
            "bool cycleInUndirectedGraph(vector<int> adj[], int n)",
            "{",
            "   vector<bool> vis(n, false);",
            "   for (int u = 0; u < n; u++) {",
            "      if (!vis[u]) {",
            "         if (dfs(u, -1, adj, vis))return true;",
            "      }",
            "   }",
            "   return false;",
            "}"
        ],
        "description": "Check cycle in undirected Graph"
    },
    "Check cycle in directed Graph": {
        "prefix": "cycleInDirectedGraph",
        "body": [
            "//call cycleInDirectedGraph to check cycle",
            "bool dfs(int s, vector<bool> &vis, vector<bool> &recSt, vector<int> adj[])",
            "{",
            "   recSt[s] = vis[s] = true;",
            "   for (int v : adj[s]) {",
            "      if (!vis[v]) {",
            "         if (dfs(v, vis, recSt, adj))return true;",
            "      }",
            "      else if (recSt[v])return true;",
            "   }",
            "   recSt[s] = false;",
            "   return false;",
            "}",
            "",
            "bool cycleInDirectedGraph(vector<int> adj[], int n)",
            "{",
            "   vector<bool> vis(n, false), recSt(n, false);",
            "   for (int u = 0; u < n; u++) {",
            "      if (!vis[u]) {",
            "         if (dfs(u, vis, recSt, adj))return true;",
            "      }",
            "   }",
            "   return false;",
            "}"
        ],
        "description": "Check cycle in directed Graph"
    },
    "Dijkstra shortest path algorithm": {
        "prefix": "dijkstra",
        "body": [
            "vector<int> dijkstra(vector<pair<int, int>> adj[], int s, int n)",
            "{",
            "   priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;",
            "   vector<int> dist(n, INT_MAX);",
            "   dist[s] = 0;",
            "   pq.push({dist[s], s});",
            "   while (!pq.empty()) {",
            "      int u = pq.top().second;",
            "      int d_u = pq.top().first;",
            "      pq.pop();",
            "      if (d_u != dist[u])continue;",
            "      for (pair<int, int> edge : adj[u]) {",
            "         int wt = edge.second;",
            "         int v = edge.first;",
            "         if (dist[u] != INT_MAX && dist[v] > dist[u] + wt) {",
            "            dist[v] = dist[u] + wt;",
            "            pq.push({dist[v], v});",
            "         }",
            "      }",
            "   }",
            "   return dist;",
            "}"
        ],
        "description": "Dijkstra shortest path algorithm"
    },
    "Bellman Ford shortest path algorithm": {
        "prefix": "bellmanFord",
        "body": [
            "vector<int> bellmanFord(vector<pair<int, int>> adj[], int s, int n)",
            "{",
            "   int INF = INT_MAX;",
            "   vector<int> dist(n, INF);",
            "   dist[s] = 0;",
            "   for (int cnt = 0; cnt < n - 1; cnt++) {",
            "      for (int i = 0; i < n; i++) {",
            "         for (pair<int, int> edge : adj[i]) {",
            "            int wt = edge.second;",
            "            int v = edge.first;",
            "            if (dist[i] != INF && dist[v] > dist[i] + wt) {",
            "               dist[v] = dist[i] + wt;",
            "            }",
            "         }",
            "      }",
            "   }",
            "   return dist;",
            "}"
        ],
        "description": "Bellman Ford shortest path algorithm"
    },
    "Detect negative cycle": {
        "prefix": "detectNegativeCycle",
        "body": [
            "bool detectNegativeCycle(vector<pair<int, int>> adj[], int s, int n)",
            "{",
            "   int INF = INT_MAX;",
            "   vector<int> dist(n, INF);",
            "   dist[s] = 0;",
            "   for (int cnt = 0; cnt < n - 1; cnt++) {",
            "      for (int i = 0; i < n; i++) {",
            "         for (pair<int, int> edge : adj[i]) {",
            "            int wt = edge.second;",
            "            int v = edge.first;",
            "            if (dist[i] != INF && dist[v] > dist[i] + wt) {",
            "               dist[v] = dist[i] + wt;",
            "            }",
            "         }",
            "      }",
            "   }",
            "   for (int i = 0; i < n; i++) {",
            "      for (pair<int, int> edge : adj[i]) {",
            "         int wt = edge.second;",
            "         int v = edge.first;",
            "         if (dist[i] != INF && dist[v] > dist[i] + wt) {",
            "            return true;",
            "         }",
            "      }",
            "   }",
            "   return false;",
            "}"
        ],
        "description": "Detect negative cycle"
    },
    "Disjoint union data structures": {
        "prefix": "DSU",
        "body": [
            "vector<int> parent;",
            "void initDSU(int N) {",
            "   parent.assign(N + 1, 0);",
            "   iota(parent.begin(), parent.end(), 0);",
            "}",
            "int findDSU(int x) {",
            "   if (x == parent[x])return x;",
            "   return parent[x] = findDSU(parent[x]);",
            "}",
            "void unionDSU(int x, int y) {",
            "   int px = findDSU(x);",
            "   int py = findDSU(y);",
            "   if (px != py) {",
            "      parent[py] = px;",
            "   }",
            "}"
        ],
        "description": "Disjoint union data structures"
    },
    "lazy_segment tree": {
        "prefix": "lazy_segtree",
        "body": [
            "struct lazy_segtree{",
            "    ll size=1,n1;",
            "    vector<ll>tree,lazy;",
            "    void init(ll n)",
            "    {",
            "        n1=n;",
            "        while(size<n)size*=2;",
            "        tree.assign(2*size,0);",
            "        lazy.assign(2*size,0);",
            "    }",
            "    void constructSTUtil(vector<ll>arr, ll left, ll right, ll x)",
            "     {",
            "        if (left>right)  return ;",
            "        if (left == right)",
            "        {",
            "            tree[x] = arr[left];",
            "            return;",
            "        }",
            "        ll mid = (left + right)/2;",
            "        constructSTUtil(arr, left, mid, x*2+1);",
            "        constructSTUtil(arr, mid+1, right, x*2+2);",
            "      ",
            "        tree[x] = tree[x*2 + 1] + tree[x*2 + 2];",
            "    }",
            "  ",
            "    void build(vector<ll>a)",
            "    {",
            "        constructSTUtil(a, 0, a.size()-1, 0);",
            "    }",
            "    void updateRangeUtil(ll x, ll left, ll right, ll l, ll r, ll diff)",
            "     {",
            "    ",
            "       if (lazy[x] != 0)",
            "        {",
            "            tree[x] += (right-left+1)*lazy[x];",
            "            if (left != right)",
            "            {",
            "                lazy[x*2 + 1]   += lazy[x];",
            "                lazy[x*2 + 2]   += lazy[x];",
            "            }",
            "            lazy[x] = 0;",
            "        }",
            "        if (left>right || left>r || right<l)",
            "            return ;",
            "        if (left>=l && right<=r)",
            "        {",
            "            tree[x] += (right-left+1)*diff;",
            "      ",
            "            if (left != right)",
            "            {",
            "                lazy[x*2 + 1]   += diff;",
            "                lazy[x*2 + 2]   += diff;",
            "            }",
            "            return;",
            "        }",
            "  ",
            "          ll mid = (left+right)/2;",
            "          updateRangeUtil(x*2+1, left, mid, l, r, diff);",
            "          updateRangeUtil(x*2+2, mid+1, right, l, r, diff);",
            "          tree[x] = tree[x*2+1] + tree[x*2+2];",
            "      }",
            "",
            "      void updateRange(ll l, ll r, ll diff)",
            "      {",
            "         updateRangeUtil(0, 0, n1-1, l, r, diff);",
            "      }",
            "      ll getSumUtil(ll left, ll right, ll qs, ll qe, ll x)",
            "      {",
            "         ",
            "          if (lazy[x] != 0)",
            "          {",
            "              ",
            "              tree[x] += (right-left+1)*lazy[x];",
            "              if (left != right)",
            "              { ",
            "                  lazy[x*2+1] += lazy[x];",
            "                  lazy[x*2+2] += lazy[x];",
            "              }",
            "              lazy[x] = 0;",
            "          }",
            "        ",
            "          if (left>right || left>qe || right<qs)",
            "              return 0;",
            "",
            "          if (left>=qs && right<=qe)",
            "              return tree[x];",
            "          ll mid = (left + right)/2;",
            "          return getSumUtil(left, mid, qs, qe, 2*x+1) +",
            "                 getSumUtil(mid+1, right, qs, qe, 2*x+2);",
            "      }",
            "      ll getSum(ll l, ll r)",
            "      {",
            "        return getSumUtil(0, n1-1, l, r, 0);",
            "      }",
            "",
            "",
            "};",
            " // lazy_segtree st;",
            " //   st.init(n);",
            " //   st.build(a);   a -> vector<ll>",
            " // cout<<st.getSum(l,r)<<endl;  return the sum from range l-r (0 based indexing)",
            " // st.updateRange(l,r,val);    adds val to the range l-r       (0 based indexing)"
        ],
        "description": "lazy_segment tree"
    },
    "segment tree": {
        "prefix": "segtree",
        "body": [
            "//range sum with point updates updates",
            "struct segtree{",
            "    ll size=1;",
            "    vector<ll>sum;",
            "    void init(ll n){",
            "        while(size<n)size*=2;",
            "        sum.assign(2*size,0);",
            "    }",
            "    void build(vector<ll>&v,ll x,ll lx,ll rx){",
            "        if(rx-lx==1){",
            "            if(lx<v.size()){",
            "                sum[x]=v[lx];",
            "            }",
            "            return;",
            "        }",
            "        ll m=(lx+rx)/2;",
            "        build(v,2*x+1,lx,m);",
            "        build(v,2*x+2,m,rx);",
            "        sum[x]=sum[2*x+1]+sum[2*x+2];",
            "    }",
            "    void build(vector<ll>&v){",
            "        build(v,0,0,size);",
            "    }",
            "    void set(ll i,ll v,ll x,ll lx,ll rx){",
            "        if(rx-lx==1){",
            "        sum[x]=v;",
            "        return;",
            "        }",
            "        ll m=(lx+rx)/2;",
            "        if(i<m){",
            "            set(i,v,2*x+1,lx,m);",
            "        }",
            "        else{",
            "            set(i,v,2*x+2,m,rx);",
            "        }",
            "        sum[x]=sum[2*x+1]+sum[2*x+2];",
            "        ",
            "    }",
            "    void set(ll i,ll v){",
            "        set(i,v,0,0,size);",
            "    }",
            "    ll calc(ll l,ll r,ll x,ll lx,ll rx){",
            "        if(lx>=r || rx<=l)",
            "        return 0;",
            "        if(lx>=l and rx<=r)",
            "        return sum[x];",
            "        ll m=(lx+rx)/2;",
            "        ll s1=calc(l,r,2*x+1,lx,m);",
            "        ll s2=calc(l,r,2*x+2,m,rx);",
            "        return s1+s2;",
            "        ",
            "    }",
            "    ll calc(ll l,ll r){",
            "        return calc(l,r+1,0,0,size);",
            "    }",
            "};",
            "// segtree st;",
            "//    st.init(n);",
            "//      st.build(a);",
            "//       st.set(index,val);              after index--;",
            "//          cout<<st.calc(l,r)<<endl;    after l--,r--;"
        ],
        "description": "segment tree"
    },
	"0-1 Knapsack": {
		"prefix": "01knapsack",
		"body": [
		  "int knapsack(int W,int val[],int w[],int n)",
		  "{",
		  "    int dp[W+1][n+1];",
		  "    for(int i=0;i<=n;i++)dp[0][i]=0;",
		  "    for(int i=0;i<=W;i++)dp[i][0]=0;",
		  "    for(int i=1;i<=W;i++)",
		  "    {",
		  "        for(int j=1;j<=n;j++)",
		  "        {",
		  "            if(w[j-1]>i)",
		  "            dp[i][j]=dp[i][j-1];",
		  "            else",
		  "            dp[i][j]=max(dp[i-w[j-1]][j-1]+val[j-1],dp[i][j-1]);",
		  "        }",
		  "    }",
		  "    return dp[W][n];",
		  "}"
		],
		"description": "0-1 Knapsack"
	},
	"Longest increasing subsequence": {
		"prefix": "lis",
		"body": [
		  "//longest increasing subsequence",
		  "int lis(int a[], int n)",
		  "{",
		  "    int tail[n];",
		  "    tail[0] = a[0];",
		  "    int len = 1;",
		  "    for (int i = 1; i < n; i++) {",
		  "        if (a[i] > tail[len - 1])tail[len++] = a[i];",
		  "        else {",
		  "            int j = lower_bound(tail, tail + len, a[i]) - tail;",
		  "            tail[j] = a[i];",
		  "        }",
		  "    }",
		  "    return len;",
		  "}"
		],
		"description": "Longest increasing subsequence"
	},
	"subset sum possible": {
		"prefix": "subsetSum",
		"body": [
		  "bool subsetSum(int a[], int N, int S)",
		  "{",
		  "    vector<vector<int>> dp(S + 1, vector<int>(N + 1, 0));",
		  "    for (int i = 0; i <= N; i++)dp[0][i] = 1;",
		  "    for (int i = 1; i <= S; i++) {",
		  "        for (int j = 1; j <= N; j++) {",
		  "            //include",
		  "            if (a[j - 1] <= i) {",
		  "                dp[i][j] = dp[i - a[j - 1]][j - 1];",
		  "            }",
		  "            dp[i][j] = dp[i][j] | dp[i][j - 1];",
		  "        }",
		  "    }",
		  "    return dp[S][N];",
		  "}"
		],
		"description": "subset sum possible"
	},
	"palindrome-String ": {
        "prefix": "palindrome",
        "body": [
            "bool ispalindrome(string s)",
            "{",
            "    int n=s.size();",
            "    for(int i=0;i<n;i++)  if(s[i]!=s[n-i-1]) return 0;",
            "    return 1;",
            "}"
        ],
        "description": "String "
    },
    "pangram-string": {
        "prefix": "pangram",
        "body": [
            "bool ispangram(string s)",
            "{",
            "    int n=s.size();",
            "    int f[26]={0}; ",
            "    for(int i=0;i<n;i++)  ",
            "     {",
            "         if(s[i]>='a' && s[i]<='z') ",
            "          f[s[i]-97]++;",
            "         else",
            "         if(s[i]>='A' && s[i]<='Z') ",
            "          f[s[i]-65]++;",
            "     }",
            "     for(int i=0;i<26;i++)",
            "     if(f[i]==0) return 0;",
            "    return 1;",
            "}"
        ],
        "description": "pangram-string"
    },
    "anagram-strings": {
        "prefix": "anagram",
        "body": [
            "bool isanagram(string a, string b)",
            "{",
            "    if(a.size()!=b.size()) return 0;",
            "    int f[26]={0}; ",
            "    for(int i=0;i<a.size();i++)  ",
            "     {",
            "         if(a[i]>='a' && a[i]<='z') ",
            "          f[a[i]-97]++;",
            "         else",
            "         if(a[i]>='A' && a[i]<='Z') ",
            "          f[a[i]-65]++;",
            "     }",
            "     for(int i=0;i<b.size();i++)  ",
            "     {",
            "         if(b[i]>='a' && b[i]<='z') ",
            "          f[b[i]-97]--;",
            "         else",
            "         if(b[i]>='A' && b[i]<='Z') ",
            "          f[b[i]-65]--;",
            "     }",
            "     for(int i=0;i<26;i++)",
            "     if(f[i]!=0) return 0;",
            "    return 1;",
            "}"
        ],
        "description": "anagram-strings"
    },
    "string->decimal": {
        "prefix": "strtodec",
        "body": [
            "long long int string_to_decimal(string s)",
            "{",
            "	long long int ans=0,p=1;",
            "    for(int i=s.size()-1;i>=0;i--)",
            "    {",
            "		ans+= p*(s[i]-'0');",
            "		p=p*10;",
            "	}",
            "	return ans;",
            "}"
        ],
        "description": "string->decimal"
    },
    "decimal->string": {
        "prefix": "dectostr",
        "body": [
            "string decimal_to_string(long long int n)",
            "{",
            "	if(n==0) return 0;",
            "	string ans="";",
            "	while(n>0)",
            "	{",
            "		ans=ans+(char)((n%10)+48);",
            "		n=n/10;",
            "	}",
            "	reverse(ans.begin(),ans.end());",
            "	return ans;",
            "}"
        ],
        "description": "decimal->string"
    },
    "occurences of pattern in a string ": {
        "prefix": "kmp",
        "body": [
            "vector<int> kmp(string s,string t)  //returns the indices of occurences of pattern t in string s",
            "{",
            "    if(s.size()<t.size())",
            "        return {};",
            "     ",
            "     int n=s.size(),m=t.size();",
            "     int lps[m+1]={0};",
            "     int len = 0,i=1,j;",
            "    while (i < m) {",
            "        if (t[i] ==t[len]) lps[i++] = ++len;",
            "        else",
            "        {",
            "            if (len != 0) len = lps[len - 1];",
            "            else   lps[i++] = 0;",
            "                        ",
            "        }",
            "    }",
            "   vector<int>ans;",
            "    i=0;j=0;",
            "    while (i<n) {",
            "        if (t[j] ==s[i]) { j++; i++; }",
            "          ",
            "        if (j == m) {",
            "            ans.pb(i-j);",
            "            j=lps[j - 1];",
            "        }",
            "        else if (i < n && t[j]!=s[i]) {",
            "            ",
            "            if (j != 0) j = lps[j - 1];",
            "            else i++;        }",
            "    }",
            "    return ans;",
            "}"
        ],
        "description": "occurences of pattern in a string "
    },
    "count of unique characters in a string": {
        "prefix": "distict_characters",
        "body": [
            "int distinct_str(string s) {",
            "  sort(s.begin(), s.end());",
            "  return unique(s.begin(), s.end()) - s.begin();",
            "}"
        ],
        "description": "count of unique characters in a string"
    },

    "longest common subsequence of two strings": {
        "prefix": "lc_subsequence",
        "body": [
            "string lc_subsequence(string a,string b)",
            "{",
            "   string ans=\"\";",
            "   int n=a.size(),m=b.size(),i,j;",
            "",
            "   int dp[n][m];",
            "   dp[0][0]= a[0]==b[0]?1:0;",
            "   for(i=1;i<n;i++) dp[i][0]= a[i]==b[0]?1:dp[i-1][0];",
            "   for(j=1;j<m;j++) dp[0][j]= a[0]==b[j]?1:dp[0][j-1];",
            "",
            "   for(i=1;i<n;i++)",
            "   {",
            "      for(j=1;j<m;j++)",
            "      {",
            "         if(a[i]==b[j]) dp[i][j]=dp[i-1][j-1]+1;",
            "         else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);",
            "      }",
            "   }",
            "   i = n-1, j = m-1;",
            "   while (i>=0 && j>=0)",
            "   {",
            "      if (a[i] == b[j])",
            "      {",
            "          ans+=a[i]; ",
            "          i--; j--;",
            "      }",
            "      else if (dp[i-1][j] > dp[i][j-1]) i--;",
            "      else j--;",
            "   }",
            "   reverse(ans.begin(),ans.end());",
            "   return ans;",
            "}"
        ],
        "description": "longest common subsequence of two strings"
    },
    "longest common substring of two strings": {
        "prefix": "lc_substring",
        "body": [
            "string lc_substring(string a,string b)",
            "{",
            "   string ans=\"\";",
            "   int n=a.size(),m=b.size(),i,j;",
            "   if(n==0 || m==0) return \"\" ;",
            "   int dp[n][m];",
            "   dp[0][0]= a[0]==b[0]?1:0;",
            "   for(i=1;i<n;i++) dp[i][0]= a[i]==b[0]?1:0;",
            "   for(j=1;j<m;j++) dp[0][j]= a[0]==b[j]?1:0;",
            "   int len=0,row,col;",
            "   for(i=1;i<n;i++)",
            "   {",
            "      for(j=1;j<m;j++)",
            "      {",
            "         if(a[i]==b[j]) dp[i][j]=dp[i-1][j-1]+1;",
            "         else dp[i][j]= 0;",
            "",
            "         if (len < dp[i][j]) {",
            "                    len = dp[i][j];",
            "                    row = i;",
            "                    col = j;",
            "                }",
            "      }",
            "   }",
            "   if(len==0) return \"\";",
            "  while (dp[row][col] != 0) {",
            "        ans+=a[row];",
            "        row--;",
            "        col--;",
            "    }",
            "   reverse(ans.begin(),ans.end());",
            "   return ans;",
            "}"
        ],
        "description": "longest common substring of two strings"
    },
    "inversions": {
        "prefix": "inversions",
        "body": [
            "long long int merge(long long int a[],long long  int temp[], int start, int mid, int end)",
            "{",
            "        int i = start;",
            "        int j = mid;",
            "        int k = start;",
            "        long long int inversion_count = 0;",
            "        while(i <= mid-1 && j<= end)",
            "        {",
            "            if(a[i]<=a[j]) temp[k++] = a[i++];",
            "            else{",
            "                inversion_count += mid-i;",
            "                temp[k++] = a[j++];",
            "            }",
            "        }",
            "        while(i <= mid-1)  temp[k++] = a[i++];",
            "        while(j <= end) temp[k++] = a[j++];",
            "        for(int i = start; i <= end; i++) a[i] = temp[i];",
            "        return inversion_count;",
            "}",
            "long long int mergeSort(long long int a[], long long int temp[], int start, int end)",
            "{",
            "        long long int inversion_count = 0;",
            "        if(start < end) {",
            "        int mid = (start+end)/2;",
            "        inversion_count += mergeSort(a, temp, start, mid);",
            "        inversion_count += mergeSort(a, temp, mid+1, end);",
            "        inversion_count += merge(a, temp, start, mid+1, end);",
            "        }",
            "        return inversion_count;",
            "        ",
            "}",
            "long long int inversions(long long  a[], long long  size)",
            "{",
            "        long long temp[size];",
            "        return mergeSort(a, temp, 0, size-1);",
            "}"
        ],
        "description": "inversions"
    },
    "bridges & cut vertices": {
    "prefix": "bridge_cutvertices",
    "body": [
        "struct bridges_cuts",
        "{",
        "   map<pair<int,int>,int>edges;",
        "   vector<pair<int,int>>bridges;",
        "   vector<vector<int>>vec;",
        "   vector<int>cuts;",
        "   vector<int>vis,tin,tout,dp,loww;",
        "   int n,timer;",
        "   bool isansestor(int u,int v) ",
        "   { return tin[u]<=tin[v] && tout[u]>=tout[v]; }",
        "",
        "   void dfs(int u,int p)",
        "  {",
        "   int j,v;",
        "   tin[u]=loww[u]=timer++;",
        "   vis[u]=1;",
        "   int child=0;",
        "   for(int v:vec[u])",
        "   {",
        "      if(v==p) continue;",
        "       if (vis[v]) {",
        "            loww[u] = min(loww[u], tin[v]);",
        "            continue;",
        "        }",
        "    edges[{u,v}]=1;",
        "       ",
        "      dfs(v,u);",
        "      loww[u]= min(loww[u], loww[v]);",
        "            if (loww[v] >= tin[u] && p!=-1)",
        "                cuts.pb(u+1);",
        "            ++child;",
        "   }",
        "   tout[u]=timer++;",
        "   if(p == -1 && child > 1)",
        "       cuts.pb(u+1);",
        "",
        "  }",
        "  void dfs2(ll u,ll p)  //to find a bridge",
        "{",
        "   // cout<<u+1<<endl;",
        "   ll j,v;",
        "   vis[u]=true;",
        "   ll goingup=0,goingdown=0,child=0;",
        "   for(int v:vec[u])",
        "   {",
        "      if(v==p) continue;",
        "      ",
        "      if(edges.count({u,v})>0 || edges.count({v,u})>0) continue;",
        "      ",
        "      if(isansestor(u,v)) { goingdown++; }",
        "      if(isansestor(v,u)) { goingup++;}",
        "      ",
        "   }",
        "   int f=0;",
        "   for(int v:vec[u])",
        "   {",
        "     ",
        "      if(vis[v]) continue;",
        "      dfs2(v,u);",
        "      dp[u]+=dp[v];",
        "      ",
        "   }",
        "   ",
        "   dp[u]=dp[u]+goingup-goingdown;",
        "  if(dp[u]==0 && u!=0) bridges.pb({min(u,p)+1,max(u,p)+1});",
        "",
        "}",
        "",
        "  void solve(vector<vector<int>>v)",
        "  {",
        "       vec=v;",
        "       n=vec.size();",
        "       dp.assign(n,0);",
        "       loww.assign(n,0);",
        "       tin.assign(n,0);",
        "       tout.assign(n,0);",
        "       vis.assign(n,0);",
        "       timer=1;",
        "       dfs(0,-1);",
        "       for(int i=0;i<n;i++) vis[i]=0;",
        "       dfs2(0,-1);",
        "  }",
        "   vector<pair<int,int>> find_bridges()",
        "   {",
        "      return bridges;",
        "   }",
        "    vector<int> find_cuts()",
        "   {",
        "      return cuts;",
        "   }",
        "",
        "};",
        "// bridges_cuts c;",
        "//    c.solve(vec);",
        "//    vector<pair<int,int>>bridges=c.find_bridges();",
        "//    vector<int>cuts=c.find_cuts();"
    ],
    "description": "bridges & cut vertices"
    },
    "sparse table": {
  "prefix": "sparse_table",
  "body": [
    "int n,q,i,j;",
    "    cin>>n;",
    "    ll a[n+1];",
    "    for(i=1;i<=n;i++) {cin>>a[i];}",
    "    int l=log2(n);",
    "    int dp[l+1][n+1];",
    "    memset(dp,0,sizeof(dp));",
    "    for(i=1;i<=n;i++)",
    "        dp[0][i]=a[i];",
    "",
    "    for(i=1;i<=l;i++)",
    "    {",
    "        for(j=1; j + (1<<i)-1 <=n;j++)",
    "            dp[i][j]=min(dp[i-1][j],dp[i-1][j+ (1<<(i-1))]);",
    "    }",
    "    cin>>q;",
    "    while(q--)",
    "    {",
    "        int l,r;",
    "",
    "        cin>>l>>r;",
    "        int x=log2(r-l+1);",
    "        cout<<min(dp[x][l],dp[x][r- (1<<x)+1])<<endl;",
    "    }"
  ],
  "description": "sparse table"
}

}

