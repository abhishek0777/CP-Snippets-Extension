{
    "CP template": {
        "prefix": "cptemplate",
        "body": [
            "#include <bits/stdc++.h>",
            "#define ll long long int",
            "#define FAST ios_base::sync_with_stdio(false); cin.tie(NULL);",
            "using namespace std;",
            "",
            "#define MOD 1000000007",
            "/*",
            "   notes",
            "",
            "*/",
            "",
            "",
            "void solve()",
            "{",
            "  ",
            "}",
            "",
            "",
            "int main() {",
            "  FAST",
            "  ll t = 1;",
            "  cin >> t;",
            "  while (t--)solve();",
            "  return 0;",
            "}"
        ],
        "description": "CP template"
    },
    "Check number is power of two": {
        "prefix": "isPowerOfTwo",
        "body": [
            "bool isPowerOfTwo(int n) {",
            "  return n && (!(n & (n - 1)));",
            "}"
        ],
        "description": "Check number is power of two"
    },
    "Check number is prime": {
        "prefix": "isPrime",
        "body": [
            "bool isPrime(int n)",
            "{",
            "  for (int i = 2; i * i <= n; i++) {",
            "    if (n % i == 0)return false;",
            "  }",
            "  return true;",
            "}"
        ],
        "description": "Check number is prime"
    },
    "return all prime factors": {
        "prefix": "primeFactors",
        "body": [
            "vector<int> primeFactors(int n)",
            "{",
            "  vector<int> v;",
            "  if (n % 2 == 0) {",
            "    v.push_back(2);",
            "    while (n % 2 == 0)n /= 2;",
            "  }",
            "  for (int i = 3; i * i <= n; i += 2) {",
            "    if (n % i == 0) {",
            "      v.push_back(i);",
            "      while (n % i == 0)n /= i;",
            "    }",
            "  }",
            "  if (n > 2)v.push_back(n);",
            "  return v;",
            "}"
        ],
        "description": "return all prime factors"
    },
    "count of all divisors": {
        "prefix": "countDivisors",
        "body": [
            "//counts the number of divisors",
            "int countDivisors(int n)",
            "{",
            "  int ans = 1;",
            "  int curr = 0;",
            "  while (n % 2 == 0)curr++, n /= 2;",
            "  ans *= (curr + 1);",
            "  curr = 0;",
            "  for (int i = 3; i * i <= n; i += 2) {",
            "    curr = 0;",
            "    while (n % i == 0) {",
            "      curr++;",
            "      n /= i;",
            "    }",
            "    ans *= (curr + 1);",
            "  }",
            "  if (n > 2)ans *= 2;",
            "  return ans;",
            "}"
        ],
        "description": "count of all divisors"
    },
    "sum of all divisors": {
        "prefix": "divisorFunction",
        "body": [
            "//return sum all divisors",
            "int divisorFunction(int n)",
            "{",
            "  int ans = 1;",
            "  int power = 0;",
            "  while (n % 2 == 0)power++, n /= 2;",
            "  //sum of GP",
            "  ans *= (pow(2, power + 1) - 1);",
            "  for (int i = 3; i * i <= n; i += 2) {",
            "    power = 0;",
            "    while (n % i == 0) {",
            "      power++;",
            "      n /= i;",
            "    }",
            "    ans *= (pow(i, power + 1) - 1) / (i - 1);",
            "  }",
            "  return ans;",
            "}"
        ],
        "description": "sum of all divisors"
    },
    "return n!": {
        "prefix": "nFactorial",
        "body": [
            "//when n! <1e18 and you need raw",
            "long long int nFactorial(int n)",
            "{",
            "  long long int ans = 1;",
            "  for (int i = 2; i <= n; i++)ans *= i;",
            "  return ans;",
            "}"
        ],
        "description": "return n!"
    },
    "return n!%mod": {
        "prefix": "nFactorialMOD",
        "body": [
            "// n!%mod  ,for ex mod=1e9+7",
            "int nFactorialMOD(int n, int mod)",
            "{",
            "  int ans = 1;",
            "  for (int i = 2; i <= n; i++)(ans *= i) %= mod;",
            "  return ans;",
            "}"
        ],
        "description": "return n!%mod"
    },
    "next power of two": {
        "prefix": "nextPowerOfTwo",
        "body": [
            "int nextPowerOfTwo(int n)",
            "{",
            "  //if n is power of two",
            "  if (n && (!n & (n - 1)))return n;",
            "  return 1 << ((int)ceil(log2(n)));",
            "}"
        ],
        "description": "next power of two"
    },
    "prev power of two": {
        "prefix": "prevPowerOfTwo",
        "body": [
            "int prevPowerOfTwo(int n)",
            "{",
            "  //if n is power of two",
            "  if (n && (!n & (n - 1)))return n;",
            "  return 1 << ((int)ceil(log2(n) - 1));",
            "}"
        ],
        "description": "prev power of two"
    },
    "x^y": {
        "prefix": "xpowery",
        "body": [
            "long long int xpowery(long long int x,long long int y) {",
            "  long long int res = 1;",
            "  /*",
            "  it depends sometimes on questions too,",
            "  whether pow(0,0) is 1 or 0",
            "  So change accordingly",
            "  */",
            "  if (x == 0)return 0LL;",
            "  while (y)",
            "  {",
            "    if (y & 1)res *= x;",
            "    y >>= 1;",
            "    x *= x;",
            "  }",
            "  return res;",
            "}"
        ],
        "description": "x^y"
    },
    "(x^y)%mod": {
        "prefix": "xpoweryMOD",
        "body": [
            "long long int xpoweryMOD(long long int x,long long int y, int mod)",
            "{",
            "  long long int res = 1;",
            "  /*",
            "  it depends sometimes on questions too,",
            "  whether pow(0,0) is 1 or 0",
            "  So change accordingly",
            "  */",
            "  if (x == 0)return 0;",
            "  while (y)",
            "  {",
            "    if (y & 1)(res *= x) %= mod;",
            "    y >>= 1;",
            "    (x *= x) %= mod;",
            "  }",
            "  return res;",
            "}"
        ],
        "description": "(x^y)%mod"
    },
    "sieve of eratosthenes": {
        "prefix": "sieve",
        "body": [
            "//return all primes b/w 1 to n",
            "vector<int> sieve(int n)",
            "{",
            "   vector<bool> is(n + 1, true);",
            "   vector<int> primes;",
            "   for (int i = 2; i * i <= n; i++) {",
            "      if (is[i]) {",
            "         for (int p = i * i; p <= n; p += i)is[p] = false;",
            "      }",
            "   }",
            "   for (int i = 2; i <= n; i++)",
            "      if (is[i])primes.push_back(i);",
            "   return primes;",
            "}"
        ],
        "description": "sieve of eratosthenes"
    },
    "Combinatorics": {
        "prefix": "combinatorics",
        "body": [
            "int SIZE = 2000005;",
            "vector<int> fact(SIZE, 1);",
            "vector<int> inv(SIZE, 1);",
            "int inverse(int x, int y)",
            "{",
            "   int res = 1;",
            "   while (y) {",
            "      if (y & 1)res = (1LL * res * x) % MOD;",
            "      y >>= 1;",
            "      x = (1LL * x * x) % MOD;",
            "   }",
            "   return res;",
            "}",
            "void initCombinatorics()",
            "{",
            "   for (int i = 2; i < SIZE; i++) {",
            "      fact[i] = (1LL * fact[i - 1] * i) % MOD;",
            "      inv[i] = inverse(fact[i], MOD - 2);",
            "   }",
            "}",
            "int nCr(int n, int r)",
            "{",
            "   int res = 1;",
            "   if (r > n)return 0;",
            "   res = (1LL * fact[n] * inv[r]) % MOD;",
            "   res = (1LL * res * inv[n - r]) % MOD;",
            "   return res;",
            "}"
        ],
        "description": "Combinatorics"
    },
    "topological sort": {
        "prefix": "topologicalSort",
        "body": [
            "vector<int> topologicalSort(vector<int> adj[], int N) {",
            "   vector<int> in(N, 0), tsort;",
            "   for (int u = 0; u < N; u++) {",
            "      for (int v : adj[u])in[v]++;",
            "   }",
            "   queue<int> q;",
            "   for (int i = 0; i < N; i++) {",
            "      if (in[i] == 0)q.push(i);",
            "   }",
            "   while (!q.empty()) {",
            "      int u = q.front();",
            "      q.pop();",
            "      tsort.push_back(u);",
            "      for (int v : adj[u]) {",
            "         in[v]--;",
            "         if (in[v] == 0)q.push(v);",
            "      }",
            "   }",
            "   return tsort;",
            "}"
        ],
        "description": "topological sort"
    },
    "Check cycle in undirected Graph": {
        "prefix": "cycleInUnDirectedGraph",
        "body": [
            "//call cycleInUndirectedGraph function to check cycle",
            "bool dfs(int s, int p, vector<int> adj[], vector<bool> &vis) {",
            "   vis[s] = true;",
            "   for (int v : adj[s]) {",
            "      if (!vis[v]){",
            "         if(dfs(v, s, adj, vis))return true;",
            "      }",
            "      else if (v != p)return true;",
            "   }",
            "   return false;",
            "}",
            "",
            "bool cycleInUndirectedGraph(vector<int> adj[], int n)",
            "{",
            "   vector<bool> vis(n, false);",
            "   for (int u = 0; u < n; u++) {",
            "      if (!vis[u]) {",
            "         if (dfs(u, -1, adj, vis))return true;",
            "      }",
            "   }",
            "   return false;",
            "}"
        ],
        "description": "Check cycle in undirected Graph"
    },
    "Check cycle in directed Graph": {
        "prefix": "cycleInDirectedGraph",
        "body": [
            "//call cycleInDirectedGraph to check cycle",
            "bool dfs(int s, vector<bool> &vis, vector<bool> &recSt, vector<int> adj[])",
            "{",
            "   recSt[s] = vis[s] = true;",
            "   for (int v : adj[s]) {",
            "      if (!vis[v]) {",
            "         if (dfs(v, vis, recSt, adj))return true;",
            "      }",
            "      else if (recSt[v])return true;",
            "   }",
            "   recSt[s] = false;",
            "   return false;",
            "}",
            "",
            "bool cycleInDirectedGraph(vector<int> adj[], int n)",
            "{",
            "   vector<bool> vis(n, false), recSt(n, false);",
            "   for (int u = 0; u < n; u++) {",
            "      if (!vis[u]) {",
            "         if (dfs(u, vis, recSt, adj))return true;",
            "      }",
            "   }",
            "   return false;",
            "}"
        ],
        "description": "Check cycle in directed Graph"
    },
    "Dijkstra shortest path algorithm": {
        "prefix": "dijkstra",
        "body": [
            "vector<int> dijkstra(vector<pair<int, int>> adj[], int s, int n)",
            "{",
            "   priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;",
            "   vector<int> dist(n, INT_MAX);",
            "   dist[s] = 0;",
            "   pq.push({dist[s], s});",
            "   while (!pq.empty()) {",
            "      int u = pq.top().second;",
            "      int d_u = pq.top().first;",
            "      pq.pop();",
            "      if (d_u != dist[u])continue;",
            "      for (pair<int, int> edge : adj[u]) {",
            "         int wt = edge.second;",
            "         int v = edge.first;",
            "         if (dist[u] != INT_MAX && dist[v] > dist[u] + wt) {",
            "            dist[v] = dist[u] + wt;",
            "            pq.push({dist[v], v});",
            "         }",
            "      }",
            "   }",
            "   return dist;",
            "}"
        ],
        "description": "Dijkstra shortest path algorithm"
    },
    "Bellman Ford shortest path algorithm": {
        "prefix": "bellmanFord",
        "body": [
            "vector<int> bellmanFord(vector<pair<int, int>> adj[], int s, int n)",
            "{",
            "   int INF = INT_MAX;",
            "   vector<int> dist(n, INF);",
            "   dist[s] = 0;",
            "   for (int cnt = 0; cnt < n - 1; cnt++) {",
            "      for (int i = 0; i < n; i++) {",
            "         for (pair<int, int> edge : adj[i]) {",
            "            int wt = edge.second;",
            "            int v = edge.first;",
            "            if (dist[i] != INF && dist[v] > dist[i] + wt) {",
            "               dist[v] = dist[i] + wt;",
            "            }",
            "         }",
            "      }",
            "   }",
            "   return dist;",
            "}"
        ],
        "description": "Bellman Ford shortest path algorithm"
    },
    "Detect negative cycle": {
        "prefix": "detectNegativeCycle",
        "body": [
            "bool detectNegativeCycle(vector<pair<int, int>> adj[], int s, int n)",
            "{",
            "   int INF = INT_MAX;",
            "   vector<int> dist(n, INF);",
            "   dist[s] = 0;",
            "   for (int cnt = 0; cnt < n - 1; cnt++) {",
            "      for (int i = 0; i < n; i++) {",
            "         for (pair<int, int> edge : adj[i]) {",
            "            int wt = edge.second;",
            "            int v = edge.first;",
            "            if (dist[i] != INF && dist[v] > dist[i] + wt) {",
            "               dist[v] = dist[i] + wt;",
            "            }",
            "         }",
            "      }",
            "   }",
            "   for (int i = 0; i < n; i++) {",
            "      for (pair<int, int> edge : adj[i]) {",
            "         int wt = edge.second;",
            "         int v = edge.first;",
            "         if (dist[i] != INF && dist[v] > dist[i] + wt) {",
            "            return true;",
            "         }",
            "      }",
            "   }",
            "   return false;",
            "}"
        ],
        "description": "Detect negative cycle"
    },
    "Disjoint union data structures": {
        "prefix": "DSU",
        "body": [
            "vector<int> parent;",
            "void initDSU(int N) {",
            "   parent.assign(N + 1, 0);",
            "   iota(parent.begin(), parent.end(), 0);",
            "}",
            "int findDSU(int x) {",
            "   if (x == parent[x])return x;",
            "   return parent[x] = findDSU(parent[x]);",
            "}",
            "void unionDSU(int x, int y) {",
            "   int px = findDSU(x);",
            "   int py = findDSU(y);",
            "   if (px != py) {",
            "      parent[py] = px;",
            "   }",
            "}"
        ],
        "description": "Disjoint union data structures"
    },
    "lazy_segment tree": {
        "prefix": "lazy_segtree",
        "body": [
            "struct lazy_segtree{",
            "    ll size=1,n1;",
            "    vector<ll>tree,lazy;",
            "    void init(ll n)",
            "    {",
            "        n1=n;",
            "        while(size<n)size*=2;",
            "        tree.assign(2*size,0);",
            "        lazy.assign(2*size,0);",
            "    }",
            "    void constructSTUtil(vector<ll>arr, ll left, ll right, ll x)",
            "     {",
            "        if (left>right)  return ;",
            "        if (left == right)",
            "        {",
            "            tree[x] = arr[left];",
            "            return;",
            "        }",
            "        ll mid = (left + right)/2;",
            "        constructSTUtil(arr, left, mid, x*2+1);",
            "        constructSTUtil(arr, mid+1, right, x*2+2);",
            "      ",
            "        tree[x] = tree[x*2 + 1] + tree[x*2 + 2];",
            "    }",
            "  ",
            "    void build(vector<ll>a)",
            "    {",
            "        constructSTUtil(a, 0, a.size()-1, 0);",
            "    }",
            "    void updateRangeUtil(ll x, ll left, ll right, ll l, ll r, ll diff)",
            "     {",
            "    ",
            "       if (lazy[x] != 0)",
            "        {",
            "            tree[x] += (right-left+1)*lazy[x];",
            "            if (left != right)",
            "            {",
            "                lazy[x*2 + 1]   += lazy[x];",
            "                lazy[x*2 + 2]   += lazy[x];",
            "            }",
            "            lazy[x] = 0;",
            "        }",
            "        if (left>right || left>r || right<l)",
            "            return ;",
            "        if (left>=l && right<=r)",
            "        {",
            "            tree[x] += (right-left+1)*diff;",
            "      ",
            "            if (left != right)",
            "            {",
            "                lazy[x*2 + 1]   += diff;",
            "                lazy[x*2 + 2]   += diff;",
            "            }",
            "            return;",
            "        }",
            "  ",
            "          ll mid = (left+right)/2;",
            "          updateRangeUtil(x*2+1, left, mid, l, r, diff);",
            "          updateRangeUtil(x*2+2, mid+1, right, l, r, diff);",
            "          tree[x] = tree[x*2+1] + tree[x*2+2];",
            "      }",
            "",
            "      void updateRange(ll l, ll r, ll diff)",
            "      {",
            "         updateRangeUtil(0, 0, n1-1, l, r, diff);",
            "      }",
            "      ll getSumUtil(ll left, ll right, ll qs, ll qe, ll x)",
            "      {",
            "         ",
            "          if (lazy[x] != 0)",
            "          {",
            "              ",
            "              tree[x] += (right-left+1)*lazy[x];",
            "              if (left != right)",
            "              { ",
            "                  lazy[x*2+1] += lazy[x];",
            "                  lazy[x*2+2] += lazy[x];",
            "              }",
            "              lazy[x] = 0;",
            "          }",
            "        ",
            "          if (left>right || left>qe || right<qs)",
            "              return 0;",
            "",
            "          if (left>=qs && right<=qe)",
            "              return tree[x];",
            "          ll mid = (left + right)/2;",
            "          return getSumUtil(left, mid, qs, qe, 2*x+1) +",
            "                 getSumUtil(mid+1, right, qs, qe, 2*x+2);",
            "      }",
            "      ll getSum(ll l, ll r)",
            "      {",
            "        return getSumUtil(0, n1-1, l, r, 0);",
            "      }",
            "",
            "",
            "};",
            " // lazy_segtree st;",
            " //   st.init(n);",
            " //   st.build(a);   a -> vector<ll>",
            " // cout<<st.getSum(l,r)<<endl;  return the sum from range l-r (0 based indexing)",
            " // st.updateRange(l,r,val);    adds val to the range l-r       (0 based indexing)"
        ],
        "description": "lazy_segment tree"
    },
    "segment tree": {
        "prefix": "segtree",
        "body": [
            "//range sum with point updates updates",
            "struct segtree{",
            "    ll size=1;",
            "    vector<ll>sum;",
            "    void init(ll n){",
            "        while(size<n)size*=2;",
            "        sum.assign(2*size,0);",
            "    }",
            "    void build(vector<ll>&v,ll x,ll lx,ll rx){",
            "        if(rx-lx==1){",
            "            if(lx<v.size()){",
            "                sum[x]=v[lx];",
            "            }",
            "            return;",
            "        }",
            "        ll m=(lx+rx)/2;",
            "        build(v,2*x+1,lx,m);",
            "        build(v,2*x+2,m,rx);",
            "        sum[x]=sum[2*x+1]+sum[2*x+2];",
            "    }",
            "    void build(vector<ll>&v){",
            "        build(v,0,0,size);",
            "    }",
            "    void set(ll i,ll v,ll x,ll lx,ll rx){",
            "        if(rx-lx==1){",
            "        sum[x]=v;",
            "        return;",
            "        }",
            "        ll m=(lx+rx)/2;",
            "        if(i<m){",
            "            set(i,v,2*x+1,lx,m);",
            "        }",
            "        else{",
            "            set(i,v,2*x+2,m,rx);",
            "        }",
            "        sum[x]=sum[2*x+1]+sum[2*x+2];",
            "        ",
            "    }",
            "    void set(ll i,ll v){",
            "        set(i,v,0,0,size);",
            "    }",
            "    ll calc(ll l,ll r,ll x,ll lx,ll rx){",
            "        if(lx>=r || rx<=l)",
            "        return 0;",
            "        if(lx>=l and rx<=r)",
            "        return sum[x];",
            "        ll m=(lx+rx)/2;",
            "        ll s1=calc(l,r,2*x+1,lx,m);",
            "        ll s2=calc(l,r,2*x+2,m,rx);",
            "        return s1+s2;",
            "        ",
            "    }",
            "    ll calc(ll l,ll r){",
            "        return calc(l,r+1,0,0,size);",
            "    }",
            "};",
            "// segtree st;",
            "//    st.init(n);",
            "//      st.build(a);",
            "//       st.set(index,val);              after index--;",
            "//          cout<<st.calc(l,r)<<endl;    after l--,r--;"
        ],
        "description": "segment tree"
    },
    "strongly connected components": {
        "prefix": "scc",
        "body": [
            "struct SCC ",
            "{",
            "     vector<vector<int>>components,v;",
            "     vector<int>vis,temp;",
            "     stack<int>st;",
            "     void dfs(int u)",
            "     {",
            "        vis[u]=1;",
            "        for(auto j:v[u]) if(!vis[j]) dfs(j);",
            "        st.push(u);",
            "     }",
            "     void dfs2(int u)",
            "     {",
            "        temp.pb(u+1);",
            "        vis[u]=1;",
            "        for(auto j:v[u]) if(!vis[j]) dfs2(j);",
            "      }",
            "    vector<pair<int,int>>edges;",
            "    vector<vector<int>> get(vector<vector<int>>vec)",
            "    {",
            "      v=vec;",
            "      int n=v.size(),i,j;",
            "       vis.resize(n);",
            "       for( i=0;i<n;i++) if(!vis[i]) dfs(i); //takes care of disconnected graph",
            "       ",
            "       for( i=0;i<v.size();i++)",
            "       for( j=0;j<v[i].size();j++)",
            "        edges.pb({i,v[i][j]});",
            "       ",
            "      for(i=0;i<v.size();i++) v[i].clear();",
            "      for( i=0;i<edges.size();i++)         //reverse the edges ",
            "       v[edges[i].s].pb(edges[i].f);",
            "      ",
            "      for( i=0;i<n;i++) vis[i]=0;",
            "",
            "      while(st.size()>0)    ",
            "      {",
            "        int u=st.top();",
            "        st.pop();",
            "        if(!vis[u])",
            "        {",
            "           if(temp.size()>0)",
            "            components.pb(temp);",
            "           temp.clear();",
            "          dfs2(u);",
            "        }",
            "",
            "      }",
            "      if(temp.size()>0) components.pb(temp);",
            "      return components;",
            "    }",
            "",
            "};"
        ],
        "description": "strongly connected components"
    },
    "inversions": {
        "prefix": "inversions",
        "body": [
            "long long int merge(long long int a[],long long  int temp[], int start, int mid, int end)",
            "{",
            "        int i = start;",
            "        int j = mid;",
            "        int k = start;",
            "        long long int inversion_count = 0;",
            "        while(i <= mid-1 && j<= end)",
            "        {",
            "            if(a[i]<=a[j]) temp[k++] = a[i++];",
            "            else{",
            "                inversion_count += mid-i;",
            "                temp[k++] = a[j++];",
            "            }",
            "        }",
            "        while(i <= mid-1)  temp[k++] = a[i++];",
            "        while(j <= end) temp[k++] = a[j++];",
            "        for(int i = start; i <= end; i++) a[i] = temp[i];",
            "        return inversion_count;",
            "}",
            "long long int mergeSort(long long int a[], long long int temp[], int start, int end)",
            "{",
            "        long long int inversion_count = 0;",
            "        if(start < end) {",
            "        int mid = (start+end)/2;",
            "        inversion_count += mergeSort(a, temp, start, mid);",
            "        inversion_count += mergeSort(a, temp, mid+1, end);",
            "        inversion_count += merge(a, temp, start, mid+1, end);",
            "        }",
            "        return inversion_count;",
            "        ",
            "}",
            "long long int inversions(long long  a[], long long  size)",
            "{",
            "        long long temp[size];",
            "        return mergeSort(a, temp, 0, size-1);",
            "}"
        ],
        "description": "inversions"
    }


}
